<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>OLED 128x32 HEX 변환</title>
<style>
  #canvas {
    image-rendering: pixelated;
    border: 1px solid black;
    cursor: crosshair;
    width: 512px;
    height: 128px;
  }
  #hexOutput {
    white-space: pre-wrap;
    font-family: monospace;
    background: #f0f0f0;
    padding: 10px;
    margin-top: 10px;
    max-height: 300px;
    overflow-y: auto;
  }
</style>
</head>
<body>

<h2>OLED 128x32 픽셀</h2>

<label>Width: <input id="oledWidth" type="number" value="128"></label>
<label>Height: <input id="oledHeight" type="number" value="32"></label>
<button onclick="applySize()">크기 적용</button>
<br/><br/>

<canvas id="canvas" width="128" height="32"></canvas><br/>

<button onclick="toggleEraserMode()">
  지우개: <span id="eraserStatus">OFF</span>
</button>
<button onclick="clearCanvas()">초기화</button>
<button onclick="generateHex()">HEX 변환</button>
<button onclick="decodeHex()">HEX 디코딩</button>
<button onclick="reorderCanvas()">배열 순서 변경</button>

<h3>HEX 코드</h3>
<textarea id="hexInput" rows="5" cols="80"></textarea>
<pre id="hexOutput"></pre>

<script>
  const canvas = document.getElementById('canvas');
  
  let width = canvas.width;
  let height = canvas.height;
let ctx = canvas.getContext('2d');

  ctx.fillStyle = 'white';
  ctx.fillRect(0, 0, width, height);

  let drawing = false;
  let eraserMode = false;

  canvas.addEventListener('mousedown', e => {
    drawing = true;
    drawPixel(e);
  });

  canvas.addEventListener('mouseup', () => drawing = false);
  canvas.addEventListener('mouseleave', () => drawing = false);
  canvas.addEventListener('mousemove', e => {
    if (drawing) drawPixel(e);
  });
  
function applySize() {
    const newWidth = parseInt(document.getElementById('oledWidth').value);
    const newHeight = parseInt(document.getElementById('oledHeight').value);

    canvas.width = newWidth;
    canvas.height = newHeight;
    
    const scale = 4;
    canvas.style.width = `${newWidth * scale}px`;
    canvas.style.height = `${newHeight * scale}px`;

    ctx = canvas.getContext('2d');

    clearCanvas();
}

  function toggleEraserMode(){
   eraserMode = !eraserMode;
   updateEraserStatus();
   }
   
   function updateEraserStatus(){
      const statusSpan = document.getElementById('eraserStatus');
      statusSpan.textContent = eraserMode ? 'ON' : 'OFF';
   }

  function drawPixel(e) {
    const rect = canvas.getBoundingClientRect();

  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;

    const x = Math.floor((e.clientX - rect.left) * scaleX);
    const y = Math.floor((e.clientY - rect.top) * scaleY);
    
    if(eraserMode){
      ctx.fillStyle = 'white';
      ctx.fillRect(x, y, 1, 1);
   } else {
    ctx.fillStyle = 'black';
    ctx.fillRect(x, y, 1, 1);
   }
  }

  function clearCanvas() {
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, width, height);
    document.getElementById('hexOutput').textContent = '';
  }

  function generateHex() {
  const width = canvas.width;
  const height = canvas.height;
  const pageHeight = 8;
  const pages = Math.ceil(height / pageHeight);

  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;

  let hexArray = [];

  for (let page = 0; page < pages; page++) {
    for (let x = 0; x < width; x++) {
      let byte = 0;
      for (let bit = 0; bit < pageHeight; bit++) {
        const y = page * pageHeight + bit;
        if (y >= height) continue; // 범위 벗어나면 건너뜀

        const idx = (y * width + x) * 4;
        const r = data[idx];
        const g = data[idx + 1];
        const b = data[idx + 2];
        const avg = (r + g + b) / 3;
        const pixelOn = avg < 128 ? 1 : 0;

        byte |= (pixelOn << bit);
      }
      hexArray.push(byte);
    }
  }

  // HEX 문자열 생성
  let hexString = '';
  for (let i = 0; i < hexArray.length; i++) {
    if (i % 16 === 0) hexString += '  ';
    hexString += '0x' + hexArray[i].toString(16).padStart(2, '0');
    if (i !== hexArray.length - 1) hexString += ', ';
    if ((i + 1) % 16 === 0) hexString += '\n';
  }

  document.getElementById('hexOutput').textContent = hexString;
}

function decodeHex() {
    const width = canvas.width;
    const height = canvas.height;
    const input = document.getElementById('hexInput').value;
    const hexArray = input.match(/0x[0-9a-fA-F]{2}/g)?.map(v => parseInt(v, 16)) || [];

    if (hexArray.length === 0) {
      alert("값을 입력하세요!");
      return;
    }

    const pages = height / 8;
    const imageData = ctx.createImageData(width, height);
for (let x = 0; x < width; x++) {
    for (let page = 0; page < pages; page++) {
      
        const byte = hexArray[page * width + x];
        for (let bit = 0; bit < 8; bit++) {
          const y = page * 8 + bit;
          const idx = (y * width + x) * 4;
          const pixelOn = (byte >> bit) & 1;
          const color = pixelOn ? 0 : 255;
          imageData.data[idx] = color;
          imageData.data[idx+1] = color;
          imageData.data[idx+2] = color;
          imageData.data[idx+3] = 255;
        }
      }
    }

    ctx.putImageData(imageData, 0, 0);
  }

</script>

</body>
</html>
